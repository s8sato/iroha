//! Code to be generated by a proc macro in future

#![allow(missing_docs)]

use std::error::Error;

use iroha_config::base::{
    Emitter, FromEnv, HumanDuration, Merge, ParseEnvResult, UnwrapPartial, UnwrapPartialResult,
    UserField,
};
use iroha_crypto::{PrivateKey, PublicKey};
use iroha_data_model::{domain::DomainId, ChainId};
use serde::Deserialize;

use crate::config::{
    base::{FromEnvResult, ReadEnv},
    user::{Account, OnlyHttpUrl, Root, Transaction},
    BasicAuth, DEFAULT_TRANSACTION_NONCE, DEFAULT_TRANSACTION_STATUS_TIMEOUT,
    DEFAULT_TRANSACTION_TIME_TO_LIVE,
};

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct RootPartial {
    pub chain_id: UserField<ChainId>,
    pub torii_url: UserField<OnlyHttpUrl>,
    pub basic_auth: UserField<BasicAuth>,
    pub account: AccountPartial,
    pub transaction: TransactionPartial,
}

impl RootPartial {
    #[allow(unused)]
    pub fn new() -> Self {
        // TODO: gen with macro
        Self::default()
    }
}

impl FromEnv for RootPartial {
    fn from_env<E: Error, R: ReadEnv<E>>(env: &R) -> FromEnvResult<Self>
    where
        Self: Sized,
    {
        let mut emitter = Emitter::new();

        let torii_url =
            ParseEnvResult::parse_simple(&mut emitter, env, "TORII_URL", "torii_url").into();

        emitter.finish()?;

        Ok(Self {
            chain_id: None.into(),
            torii_url,
            basic_auth: None.into(),
            account: AccountPartial::default(),
            transaction: TransactionPartial::default(),
        })
    }
}

impl UnwrapPartial for RootPartial {
    type Output = Root;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.chain_id.is_none() {
            emitter.emit_missing_field("chain_id");
        }
        if self.torii_url.is_none() {
            emitter.emit_missing_field("torii_url");
        }
        let account = emitter.try_unwrap_partial(self.account);
        let transaction = emitter.try_unwrap_partial(self.transaction);

        emitter.finish()?;

        Ok(Root {
            chain_id: self.chain_id.get().unwrap(),
            torii_url: self.torii_url.get().unwrap(),
            basic_auth: self.basic_auth.get(),
            account: account.unwrap(),
            transaction: transaction.unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct AccountPartial {
    pub domain_id: UserField<DomainId>,
    pub public_key: UserField<PublicKey>,
    pub private_key: UserField<PrivateKey>,
}

impl UnwrapPartial for AccountPartial {
    type Output = Account;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        let mut emitter = Emitter::new();

        if self.domain_id.is_none() {
            emitter.emit_missing_field("account.domain_id");
        }
        if self.public_key.is_none() {
            emitter.emit_missing_field("account.public_key");
        }
        if self.private_key.is_none() {
            emitter.emit_missing_field("account.private_key");
        }

        emitter.finish()?;

        Ok(Account {
            domian_id: self.domain_id.get().unwrap(),
            public_key: self.public_key.get().unwrap(),
            private_key: self.private_key.get().unwrap(),
        })
    }
}

#[derive(Debug, Clone, Deserialize, Eq, PartialEq, Default, Merge)]
#[serde(deny_unknown_fields, default)]
pub struct TransactionPartial {
    pub time_to_live: UserField<HumanDuration>,
    pub status_timeout: UserField<HumanDuration>,
    pub nonce: UserField<bool>,
}

impl UnwrapPartial for TransactionPartial {
    type Output = Transaction;

    fn unwrap_partial(self) -> UnwrapPartialResult<Self::Output> {
        Ok(Transaction {
            time_to_live: self
                .time_to_live
                .get()
                .map_or(DEFAULT_TRANSACTION_TIME_TO_LIVE, HumanDuration::get),
            status_timeout: self
                .status_timeout
                .get()
                .map_or(DEFAULT_TRANSACTION_STATUS_TIMEOUT, HumanDuration::get),
            nonce: self.nonce.get().unwrap_or(DEFAULT_TRANSACTION_NONCE),
        })
    }
}
